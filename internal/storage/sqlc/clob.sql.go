// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: clob.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAvailableToken = `-- name: GetAvailableToken :many
SELECT 
    d.name AS debt_token_name, 
    d.symbol AS debt_token_symbol, 
    d.address AS debt_token_address,
    d.icon AS debt_token_icon,
    c.name AS collateral_token_name, 
    c.symbol AS collateral_token_symbol, 
    c.address AS collateral_address,
    c.icon AS collateral_token_icon,
    CONCAT(
        (SELECT month_name FROM maturities WHERE id = MIN(m.id)), ' ', 
        (SELECT year FROM maturities WHERE id = MIN(m.id)), 
        ' ~ ', 
        (SELECT month_name FROM maturities WHERE id = MAX(m.id)), ' ', 
        (SELECT year FROM maturities WHERE id = MAX(m.id))
    ) AS maturity_range,
    CONCAT(MIN(o.rate), '% ~ ', MAX(o.rate), '%') AS rate_range,
    SUM(CASE WHEN o.order_type = 'LEND' THEN o.available_token ELSE 0 END) AS lending_vault,
    SUM(CASE WHEN o.order_type = 'BORROW' THEN o.available_token ELSE 0 END) AS borrow_vault
FROM orders o
JOIN token c ON o.collateral_token_id = c.id
JOIN token d ON o.debt_token_id = d.id
JOIN maturities m ON o.maturity_id = m.id
GROUP BY d.id, c.id
`

type GetAvailableTokenRow struct {
	DebtTokenName         string
	DebtTokenSymbol       string
	DebtTokenAddress      string
	DebtTokenIcon         pgtype.Text
	CollateralTokenName   string
	CollateralTokenSymbol string
	CollateralAddress     string
	CollateralTokenIcon   pgtype.Text
	MaturityRange         interface{}
	RateRange             interface{}
	LendingVault          int64
	BorrowVault           int64
}

func (q *Queries) GetAvailableToken(ctx context.Context) ([]GetAvailableTokenRow, error) {
	rows, err := q.db.Query(ctx, getAvailableToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableTokenRow
	for rows.Next() {
		var i GetAvailableTokenRow
		if err := rows.Scan(
			&i.DebtTokenName,
			&i.DebtTokenSymbol,
			&i.DebtTokenAddress,
			&i.DebtTokenIcon,
			&i.CollateralTokenName,
			&i.CollateralTokenSymbol,
			&i.CollateralAddress,
			&i.CollateralTokenIcon,
			&i.MaturityRange,
			&i.RateRange,
			&i.LendingVault,
			&i.BorrowVault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestRate = `-- name: GetBestRate :one
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY rate) AS best_rate
FROM orders o
JOIN token c ON o.collateral_token_id = c.id
JOIN token d ON o.debt_token_id = d.id
JOIN maturities m ON o.maturity_id = m.id
WHERE c.address = $1 AND d.address = $2 AND m.month = $3 AND m.year = $4
`

type GetBestRateParams struct {
	Address   string
	Address_2 string
	Month     int32
	Year      int32
}

func (q *Queries) GetBestRate(ctx context.Context, arg GetBestRateParams) (float64, error) {
	row := q.db.QueryRow(ctx, getBestRate,
		arg.Address,
		arg.Address_2,
		arg.Month,
		arg.Year,
	)
	var best_rate float64
	err := row.Scan(&best_rate)
	return best_rate, err
}

const getCLOB = `-- name: GetCLOB :many
SELECT rate, available_token, order_type
FROM orders o
JOIN token c ON o.collateral_token_id = c.id
JOIN token d ON o.debt_token_id = d.id
JOIN maturities m ON o.maturity_id = m.id
WHERE c.address = $1 AND d.address = $2 AND m.month = $3 AND m.year = $4
`

type GetCLOBParams struct {
	Address   string
	Address_2 string
	Month     int32
	Year      int32
}

type GetCLOBRow struct {
	Rate           pgtype.Numeric
	AvailableToken int32
	OrderType      string
}

func (q *Queries) GetCLOB(ctx context.Context, arg GetCLOBParams) ([]GetCLOBRow, error) {
	rows, err := q.db.Query(ctx, getCLOB,
		arg.Address,
		arg.Address_2,
		arg.Month,
		arg.Year,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCLOBRow
	for rows.Next() {
		var i GetCLOBRow
		if err := rows.Scan(&i.Rate, &i.AvailableToken, &i.OrderType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaturitiesAndBestRate = `-- name: GetMaturitiesAndBestRate :many
SELECT 
    CONCAT(m.month_name, ' ', m.year) AS maturity,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY o.rate) AS best_rate
FROM orders o
JOIN maturities m ON o.maturity_id = m.id
JOIN token c ON o.collateral_token_id = c.id
JOIN token d ON o.debt_token_id = d.id
WHERE c.address = $1 
AND d.address = $2
GROUP BY m.id, m.month_name, m.year
ORDER BY m.year ASC, m.month ASC
`

type GetMaturitiesAndBestRateParams struct {
	Address   string
	Address_2 string
}

type GetMaturitiesAndBestRateRow struct {
	Maturity interface{}
	BestRate float64
}

func (q *Queries) GetMaturitiesAndBestRate(ctx context.Context, arg GetMaturitiesAndBestRateParams) ([]GetMaturitiesAndBestRateRow, error) {
	rows, err := q.db.Query(ctx, getMaturitiesAndBestRate, arg.Address, arg.Address_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMaturitiesAndBestRateRow
	for rows.Next() {
		var i GetMaturitiesAndBestRateRow
		if err := rows.Scan(&i.Maturity, &i.BestRate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomOrder = `-- name: GetRandomOrder :one
SELECT id FROM orders
ORDER BY RANDOM()
`

func (q *Queries) GetRandomOrder(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getRandomOrder)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateAvailable = `-- name: UpdateAvailable :one
UPDATE orders o
SET available_token = $1
FROM token c, token d, maturities m
WHERE o.collateral_token_id = c.id
AND o.debt_token_id = d.id
AND o.maturity_id = m.id
AND c.address = $2
AND d.address = $3
AND m.month = $4
AND m.year = $5
AND o.order_type = $6
AND o.rate = $7
RETURNING o.id
`

type UpdateAvailableParams struct {
	AvailableToken int32
	Address        string
	Address_2      string
	Month          int32
	Year           int32
	OrderType      string
	Rate           pgtype.Numeric
}

func (q *Queries) UpdateAvailable(ctx context.Context, arg UpdateAvailableParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateAvailable,
		arg.AvailableToken,
		arg.Address,
		arg.Address_2,
		arg.Month,
		arg.Year,
		arg.OrderType,
		arg.Rate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateTokenAvailable = `-- name: UpdateTokenAvailable :exec
UPDATE orders
SET available_token = available_token + $1
WHERE id = $2
`

type UpdateTokenAvailableParams struct {
	AvailableToken int32
	ID             int32
}

func (q *Queries) UpdateTokenAvailable(ctx context.Context, arg UpdateTokenAvailableParams) error {
	_, err := q.db.Exec(ctx, updateTokenAvailable, arg.AvailableToken, arg.ID)
	return err
}
