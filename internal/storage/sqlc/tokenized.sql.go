// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tokenized.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllToken = `-- name: GetAllToken :many
SELECT 
    q.name AS quote_token_name, 
    q.symbol AS quote_token_symbol, 
    q.address AS quote_token_address,
    q.icon AS quote_token_icon,
    b.name AS base_token_name, 
    b.symbol AS base_token_symbol, 
    b.address AS base_token_address,
    b.icon AS base_token_icon,
    CONCAT(MIN(t.price), ' ~ ', MAX(t.price)) AS price_range,
    CONCAT(
        (SELECT month_name FROM maturities WHERE id = MIN(m.id)), ' ', 
        (SELECT year FROM maturities WHERE id = MIN(m.id)), 
        ' ~ ', 
        (SELECT month_name FROM maturities WHERE id = MAX(m.id)), ' ', 
        (SELECT year FROM maturities WHERE id = MAX(m.id))
    ) AS maturity_range,
    SUM(t.volume) AS volume24h
FROM tokenized t
JOIN token q ON t.quote_token_id = q.id
JOIN token b ON t.base_token_id = b.id
JOIN maturities m ON t.maturity_id = m.id
GROUP BY q.id, b.id
`

type GetAllTokenRow struct {
	QuoteTokenName    string
	QuoteTokenSymbol  string
	QuoteTokenAddress string
	QuoteTokenIcon    pgtype.Text
	BaseTokenName     string
	BaseTokenSymbol   string
	BaseTokenAddress  string
	BaseTokenIcon     pgtype.Text
	PriceRange        interface{}
	MaturityRange     interface{}
	Volume24h         int64
}

func (q *Queries) GetAllToken(ctx context.Context) ([]GetAllTokenRow, error) {
	rows, err := q.db.Query(ctx, getAllToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTokenRow
	for rows.Next() {
		var i GetAllTokenRow
		if err := rows.Scan(
			&i.QuoteTokenName,
			&i.QuoteTokenSymbol,
			&i.QuoteTokenAddress,
			&i.QuoteTokenIcon,
			&i.BaseTokenName,
			&i.BaseTokenSymbol,
			&i.BaseTokenAddress,
			&i.BaseTokenIcon,
			&i.PriceRange,
			&i.MaturityRange,
			&i.Volume24h,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBasePrice = `-- name: GetBasePrice :one
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY price) AS best_price
FROM tokenized t
JOIN token q ON t.quote_token_id = q.id
JOIN token b ON t.base_token_id = b.id
JOIN maturities m ON t.maturity_id = m.id
WHERE q.address = $1 AND b.address = $2 AND m.month = $3 AND m.year = $4 AND t.rate = $5
`

type GetBasePriceParams struct {
	Address   string
	Address_2 string
	Month     int32
	Year      int32
	Rate      pgtype.Numeric
}

func (q *Queries) GetBasePrice(ctx context.Context, arg GetBasePriceParams) (float64, error) {
	row := q.db.QueryRow(ctx, getBasePrice,
		arg.Address,
		arg.Address_2,
		arg.Month,
		arg.Year,
		arg.Rate,
	)
	var best_price float64
	err := row.Scan(&best_price)
	return best_price, err
}

const getRandomToken = `-- name: GetRandomToken :one
SELECT id FROM tokenized
ORDER BY RANDOM()
`

func (q *Queries) GetRandomToken(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getRandomToken)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getToken = `-- name: GetToken :many
SELECT price, amount, order_type
FROM tokenized t
JOIN token q ON t.quote_token_id = q.id
JOIN token b ON t.base_token_id = b.id
JOIN maturities m ON t.maturity_id = m.id
WHERE q.address = $1 AND b.address = $2 AND m.month = $3 AND m.year = $4 AND t.rate = $5
`

type GetTokenParams struct {
	Address   string
	Address_2 string
	Month     int32
	Year      int32
	Rate      pgtype.Numeric
}

type GetTokenRow struct {
	Price     pgtype.Numeric
	Amount    int32
	OrderType string
}

func (q *Queries) GetToken(ctx context.Context, arg GetTokenParams) ([]GetTokenRow, error) {
	rows, err := q.db.Query(ctx, getToken,
		arg.Address,
		arg.Address_2,
		arg.Month,
		arg.Year,
		arg.Rate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTokenRow
	for rows.Next() {
		var i GetTokenRow
		if err := rows.Scan(&i.Price, &i.Amount, &i.OrderType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tokenAmount = `-- name: TokenAmount :exec
UPDATE tokenized
SET amount = amount + $1
WHERE id = $2
`

type TokenAmountParams struct {
	Amount int32
	ID     int32
}

func (q *Queries) TokenAmount(ctx context.Context, arg TokenAmountParams) error {
	_, err := q.db.Exec(ctx, tokenAmount, arg.Amount, arg.ID)
	return err
}

const tokenVolume = `-- name: TokenVolume :exec
UPDATE tokenized
SET volume = volume + $1
WHERE id = $2
`

type TokenVolumeParams struct {
	Volume int32
	ID     int32
}

func (q *Queries) TokenVolume(ctx context.Context, arg TokenVolumeParams) error {
	_, err := q.db.Exec(ctx, tokenVolume, arg.Volume, arg.ID)
	return err
}

const updateAmount = `-- name: UpdateAmount :one
UPDATE tokenized t
SET amount = $1
FROM token q, token b, maturities m
WHERE t.quote_token_id = q.id
AND t.base_token_id = b.id
AND t.maturity_id = m.id
AND q.address = $2
AND b.address = $3
AND m.month = $4
AND m.year = $5
AND t.order_type = $6
AND t.rate = $7
RETURNING t.id
`

type UpdateAmountParams struct {
	Amount    int32
	Address   string
	Address_2 string
	Month     int32
	Year      int32
	OrderType string
	Rate      pgtype.Numeric
}

func (q *Queries) UpdateAmount(ctx context.Context, arg UpdateAmountParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateAmount,
		arg.Amount,
		arg.Address,
		arg.Address_2,
		arg.Month,
		arg.Year,
		arg.OrderType,
		arg.Rate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
